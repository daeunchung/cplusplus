/*
11657 음수 간선이 존재하는 그래프 - 벨만포드 알고리즘
 다익스트라 O(ElogV) 로 음의간선 있을시 사용 불가능,  벨만포트 O(VE) 음의간선 있는경우 사용 가능

 V를 정점이라고 할 때 벨만-포드 알고리즘에서는 V-1번의 반복문을 돌고나면 최단 거리가 완성됩니다. 
 그리고 여기서 반복문을 한번 더 돌렸을 때 최단거리가 갱신이 된다면 음의 싸이클이 존재한다는 의미이므로
 i가 N일 때 최단거리가 갱신될 시에 bool형 변수인 cycle을 true로 저장합니다.

 최단경로 알고리즘은 크게 다익스트라와 벨만-포드 알고리즘 두 가지가 있습니다. 
 다익스트라 알고리즘은 엣지 가중치가 음수일 경우 동작하지 않습니다. 
 벨만-포드 알고리즘의 경우 엣지 가중치가 음수여도 동작하나, negative cycle이 있을 경우 동작하지 않습니다. 
 다익스트라 알고리즘의 계산복잡성은 O(|V|2+|E|)이며, 벨만-포드는 O(|V||E|)입니다.
 전체쌍(All-pair) 최단경로 문제는 Floyd-Warshall 알고리즘이 널리 쓰인다고 합니다
 다만 노드가 다르다면 단일쌍 최단경로 문제는 서로 독립적이기 때문에, 
 최근엔 단일쌍 문제에 적합한 다익스트라/벨만-포드 알고리즘을 GPU를 활용해 
 병렬처리하는 방식으로 전체쌍 최단경로를 푸는 경우가 많다고 합니다.

 도시의 개수 N (1 ≤ N ≤ 500), 버스 노선의 개수 M (1 ≤ M ≤ 6,000)
 M개의 줄에는 버스 노선의 정보 A, B, C (1 ≤ A, B ≤ N, -10,000 ≤ C ≤ 10,000)
 */
//#include <iostream>
//#include <bits/stdc++.h>
//using namespace std;
//#define INF 2100000000	// 21억
//
//// 인접 리스트
//vector<pair<int, int>> v[501];
//int N, M, A, B, C, a, b;
//long long dist[501];
//
//int main()
//{
//	ios_base::sync_with_stdio(false);	cin.tie(nullptr);
//	cin >> N >> M;	// 정점수 >> 간선수
//	for (int i = 0; i < M; i++)
//	{
//		cin >> A >> B >> C;
//		v[A].push_back({ B,C });
//	}
//
//	for (int i = 1; i <= N; i++)
//		dist[i] = INF; // 모든 노드를 INF로 세팅
//
//	return 0;
//}